import path from 'path';
import plugins from 'gulp-load-plugins';
import yargs from 'yargs';
import browser from 'browser-sync';
import gulp from 'gulp';
import panini from 'panini';
import rimraf from 'rimraf';
import yaml from 'js-yaml';
import fs from 'fs';
import webpackStream from 'webpack-stream';
import webpack2 from 'webpack';
import named from 'vinyl-named';
import sitemap from 'gulp-sitemap';
import through from 'through2';
import cachebuster from 'gulp-cache-bust';
import handlebars from 'handlebars';
import rename from 'gulp-rename';
import postcss from 'gulp-postcss';

const webpackConfig = require('./webpack.config.js');

// Load all Gulp plugins into one variable
const $ = plugins();

// Check for --production flag
const PRODUCTION = !!yargs.argv.production;

// Load settings from settings.yml
const { COMPATIBILITY, PORT, UNCSS_OPTIONS, PATHS } = loadConfig();

function loadConfig() {
  const ymlFile = fs.readFileSync('config.yml', 'utf8');
  return yaml.load(ymlFile);
}

// Delete the "dist" folder
// This happens every time a build starts
function clean(done) {
  rimraf(PATHS.dist, done);
}

// Copy files out of the assets folder
// This task skips over the "img", "js", and "scss" folders, which are parsed separately
function copy() {
  gulp.src(PATHS.rootassets).pipe(gulp.dest(PATHS.dist));

  return gulp.src(PATHS.assets).pipe(gulp.dest(`${PATHS.dist}/assets`));
}

// Copy page templates into finished HTML files
function pages() {
  return gulp
    .src('src/pages/**/*.{html,hbs,handlebars}')
    .pipe(
      panini({
        root: 'src/pages/',
        layouts: 'src/layouts/',
        pageLayouts: {
          // All pages inside src/pages/speakers will use the speaker-layout.html layout
          speakers: 'speaker-layout'
        },
        partials: 'src/partials/',
        data: 'src/data/',
        helpers: 'src/helpers/'
      })
    )
    .pipe(gulp.dest(PATHS.dist));
}

/**
 * Generate many pages for many speakers defined in data/speakers.json
 * @returns {*}
 */
function cachebusting() {
  return gulp
    .src(`${PATHS.dist}/*.html`)
    .pipe(
      cachebuster({
        type: 'timestamp'
      })
    )
    .pipe(gulp.dest(PATHS.dist));
}

function generateSpeakersPages(done) {
  // eslint-disable-next-line global-require
  const speakers = require('./src/data/speakers.json') || [];

  speakers.forEach((speaker) => {
    const fileName = speaker.name.toLowerCase().replace(/\s+/g, '-');
    // console.log(fileName);

    // load panini custom helpers
    function registerCustomHelpers() {
      // eslint-disable-next-line global-require
      const utils = require('panini/lib/utils');
      const helpers = utils.loadFiles('./src/helpers', '**/*.js');

      for (let i in helpers) {
        let helper;
        const name = path.basename(helpers[i], '.js');

        try {
          if (handlebars.helpers[name]) {
            delete require.cache[require.resolve(path.join(helpers[i]))];
            handlebars.unregisterHelper(name);
          }

          // eslint-disable-next-line global-require
          helper = require(path.join(helpers[i]));
          handlebars.registerHelper(name, helper);
        }
        catch (e) {
          // eslint-disable-next-line no-console
          console.warn(`Error when loading ${name}.js as a Handlebars helper.`);
        }
      }
    }

    gulp.src('src/speaker-template.html')
    // eslint-disable-next-line func-names
      .pipe(through.obj(
        function (file, enc, cb) {

          registerCustomHelpers();
          const template = handlebars.compile(file.contents.toString());
          // eslint-disable-next-line no-param-reassign
          file.contents = new Buffer(template(speaker));
          this.push(file);
          cb();
        })
      )
      .pipe(rename({ basename: fileName }))
      .pipe(gulp.dest('src/pages/speakers'));
  });

  done();
}

/**
 * Copy the generated speakers pages to the root
 */
function copyGeneratedSpeakersPages() {
  return gulp.src('static/speakers/*.html')
    .pipe(gulp.dest('static'));
}

// -------------------------------------
// Task: Sitemap
// Generate sitemap.xml based on HTML
// pages generated by panini
// *** must be called after panini task
// -------------------------------------
function sitemapxml() {
  return gulp
    .src('static/*.html', { read: false })
    .pipe(
      sitemap({
        siteUrl: 'http://wudmilan.com',
        spacing: '  '
      })
    )
    .pipe(gulp.dest(PATHS.dist));
}

// Load updated HTML templates and partials into Panini
function resetPages(done) {
  panini.refresh();
  done();
}

// Compile Sass into CSS
// In production, the CSS is compressed
function sass() {
  return (
    gulp
      .src('src/assets/sass/app.scss')
      .pipe($.sourcemaps.init())
      .pipe(
        $.sass({
          includePaths: PATHS.sass
        }).on('error', $.sass.logError)
      )
      .pipe(
        $.autoprefixer({
          browsers: COMPATIBILITY
        })
      )
      .pipe(postcss([require('postcss-flexbugs-fixes')]))
      // Comment in the pipe below to run UnCSS in production
      // .pipe($.if(PRODUCTION, $.uncss(UNCSS_OPTIONS)))
      .pipe($.if(PRODUCTION, $.cleanCss({ compatibility: 'ie9' })))
      .pipe($.if(!PRODUCTION, $.sourcemaps.write()))
      .pipe(gulp.dest(`${PATHS.dist}/assets/css`))
      .pipe(browser.reload({ stream: true }))
  );
}

// Combine JavaScript into one file
// In production, the file is minified
function javascript() {
  return (
    gulp
      .src(PATHS.entries)
      .pipe(named())
      // .pipe($.sourcemaps.init())
      .pipe(webpackStream(webpackConfig, webpack2))
      .pipe($.sourcemaps.init({ loadMaps: true }))
      .pipe(
        through.obj(function (file, enc, cb) {
          // Dont pipe through any source map files as it will be handled
          // by gulp-sourcemaps
          const isSourceMap = /\.mapplugin/.test(file.path);
          if (!isSourceMap) {
            this.push(file);
          }

          cb();
        })
      )
      // .pipe($.if(PRODUCTION, $.uglify()
      //   .on('error', e => {
      //     // eslint-disable-next-line no-console
      //     console.log(e);
      //   })
      // ))
      .pipe($.if(!PRODUCTION, $.sourcemaps.write('.')))
      .pipe(gulp.dest(`${PATHS.dist}/assets/js`))
  );
}

// Copy images to the "dist" folder
// In production, the images are compressed
function images() {
  return gulp
    .src('src/assets/img/**/*')
    .pipe(
      $.if(
        PRODUCTION,
        $.imagemin({
          progressive: true
        })
      )
    )
    .pipe(gulp.dest(`${PATHS.dist}/assets/img`));
}

// Start a server with BrowserSync to preview the site in
function server(done) {
  browser.init({
    server: PATHS.dist,
    port: PORT,
    // browser: browser === undefined ? 'google chrome' : browser,
    browser: 'google chrome',
    https: true
  });
  done();
}

// Reload the browser with BrowserSync
function reload(done) {
  browser.reload();
  done();
}

// Watch for changes to static assets, pages, Sass, and JavaScript
function watch() {
  gulp.watch(PATHS.assets, copy);

  gulp
    .watch('src/pages/**/*.html')
    .on('all', gulp.series(pages, cachebusting, sitemapxml, browser.reload));

  gulp
    .watch('src/{layouts,partials}/**/*.html')
    .on(
      'all',
      gulp.series(resetPages, pages, cachebusting, sitemapxml, browser.reload)
    );

  gulp
    .watch('src/data/**/*')
    .on('all', gulp.series(resetPages, pages, cachebusting, browser.reload));

  gulp.watch('src/assets/sass/**/*.scss').on('all', sass);

  gulp
    .watch('src/assets/js/**/*.js')
    .on('all', gulp.series(javascript, cachebusting, browser.reload));

  gulp
    .watch('src/assets/img/**/*')
    .on('all', gulp.series(images, browser.reload));

  // regenerate speakers pages if the speaker template change
  gulp
    .watch('src/speaker-template.html')
    .on(
      'all',
      gulp.series(generateSpeakersPages, pages, copyGeneratedSpeakersPages, sitemapxml, browser.reload)
    );

  // regenerate speakers pages if the speaker template change
  gulp
    .watch('src/data/speakers.json')
    .on(
      'all',
      gulp.series(generateSpeakersPages, pages, copyGeneratedSpeakersPages, sitemapxml, browser.reload)
    );
}


gulp.task('generateSpeakersPages', gulp.series(generateSpeakersPages));

// Build the "dist" folder by running all of the below tasks
gulp.task(
  'build',
  gulp.series(
    clean,
    generateSpeakersPages,
    pages,
    copyGeneratedSpeakersPages,
    gulp.parallel(sass, javascript, images, copy),
    cachebusting,
    sitemapxml
  )
);

// Build the site, run the server, and watch for file changes
gulp.task('default', gulp.series('build', server, watch));
